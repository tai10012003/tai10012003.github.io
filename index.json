[
{
	"uri": "https://tai10012003.github.io/",
	"title": "Build a Basic Serverless Product Management Website with AWS Services",
	"tags": [],
	"description": "",
	"content": "Build a basic serverless product management Website with AWS services Overview In this lab, we will learn how to create a simple serverless website using AWS services like S3, Lambda, API Gateway, and DynamoDB. The application will include CRUD (Create, Read, Update, Delete) features for managing products. With the serverless approach, we wonâ€™t need to manage servers, letting we focus on building your application while keeping costs low and scaling easily.\nContent Introduction Preparation Create Table DynamoDB Lambda Function API Gateway S3 Setup Test results Clean up resources "
},
{
	"uri": "https://tai10012003.github.io/5-apigateway/5.1-createapigateway/",
	"title": "Create API Gateway",
	"tags": [],
	"description": "",
	"content": "Create API Gateway In this step of creating an API Gateway, we will create a REST API to act as an interface between the application and the Lambda Function. The API Gateway will define structured endpoints (e.g. /products, /product) to handle HTTP requests like GET, POST, PUT, and DELETE.\nSearch for API Gateway in the search bar and click on API Gateway. In the Create API, scroll down REST API section, click Build button. In the Create REST API, provide the following details: API Name: Enter a name for your API (e.g. ProductAPI)\nDescription: Add an optional description.\nAPI Endpoint Type: Select Regional.\nClick Create API button to proceed.\nAfter creating the REST API, a confirmation message will appear at the top of the screen: Successfully created REST API.\nIn the ProductAPI section created, navigate to the Resources section, click Create Resource button.\nIn the Create resource, add the following resources: Resource Name: Enter a name for the resource: products\nClick enable CORS (Cross Origin Resource Sharing).\nClick Create resource button.\nYou need to enable CORS to allow the S3-hosted interface to send requests to API Gateway, since the interface and API Gateway may be on different domains or origins. If CORS is not enabled, the browser will block requests from the S3-hosted interface to the API Gateway due to a violation of the browser\u0026rsquo;s default security policy, known as the Same-Origin Policy.\nAfter creating the resource, a confirmation message will appear at the top of the screen: Successfully created resource. Similarly, create another resource: product like step 6. In the Resources, choose /products resource and click Create method button: In the Create method, Method details section provide the following details: GET:\nMethod Type: select GET.\nIntegration Type: select Lambda Function.\nClick enable Lambda proxy integration.\nSelect your current region (e.g. us-east-1). Select the Lambda Function name that you created earlier in section 4.2. Create Lambda Function (e.g. ProductCRUDFunction)\nScroll down and click Create method button.\nEnable Lambda proxy integration: API Gateway passes all HTTP requests (headers, queries, body, methods) directly to Lambda. Lambda handles all logic and responses. Without enabling Lambda proxy integration: API Gateway only sends pre-configured data (Mapping Templates) to Lambda. Parameters and responses must be manually configured in API Gateway.\nAfter creating the method, a confirmation message will appear at the top of the screen: the method was successfully created. Similarly, create a POST method for /products resource. Similarly, for the /product resource, add the following methods: GET: To fetch a product by ID.\nPUT: To update a product.\nDELETE: To delete a product.\nConfigure each method similarly by integrating it with the appropriate Lambda Function like step: 9, 10.\nWe have completed creating REST API. Next we will Deploy API. "
},
{
	"uri": "https://tai10012003.github.io/4-lambdafunc/4.1-iamrole/",
	"title": "Create IAM Role for Lambda and DynamoDB",
	"tags": [],
	"description": "",
	"content": "Create IAM Role for Lambda and DynamoDB In this case, we will create an IAM Role to allow Lambda Function to perform operations on DynamoDB. This IAM Role will help connect Lambda and DynamoDB securely without storing Access Key in the source code.\nSearch for IAM in the search bar and click on IAM. In the IAM Console, go to the Roles section. Click the Create role button. In the Create role. Provide the following details: In step 1: Select Trusted Entity:\nTrusted entity type section: Choose AWS Service.\nIn the Use case section: Select Lambda as the use case.\nClick Next button to continue.\nIn step 2: Add permissions:\nIn the Permissions policies section, use the search bar to type AWSLambda_FullAccess. When the results appear, select AWSLambda_FullAccess by checking the box next to it. This permission allows Lambda Functions to have full access to the services needed to execute code and manage resources on AWS.\nNext, use the search bar to type AmazonDynamoDBFullAccess. When the results appear, select AmazonDynamoDBFullAccess by checking the box next to it. This permission allows the Lambda Function to perform full operations (Create, Read, Update, Delete) on DynamoDB, ensuring efficient interaction with the data table.\nAfter, click Next button to continue.\nIn step 3: Name, review and create:\nRole details section: Role name: Enter a name for your role (e.g. role-lambda-dynamo). Description: Add an optional description.\nIn the Permission policy summary section, review the attached policies to ensure they include AWSLambda_FullAccess and AmazonDynamoDBFullAccess.\nAfter, click Create role button to proceed.\nAfter creating the role, a confirmation message will appear at the top of the screen: The role was successfully created. We have completed creating IAM Roles for Lambda and DynamoDB. Next we will create Lambda Function. "
},
{
	"uri": "https://tai10012003.github.io/6-s3setup/6.1-essentialprojectfiles/",
	"title": "Essential project files",
	"tags": [],
	"description": "",
	"content": "In this step, we will create the key files needed for the frontend of our application. These include:\nindex.html: This file sets up the structure and design of the user interface. It includes a form for adding or updating products, a list to display them, and buttons for editing or deleting products. Simple CSS is used to make the page look clean and modern.\napp.js: This file contains the JavaScript code to handle product actions like adding, updating, fetching, and deleting through the API Gateway. It also updates the user interface based on user actions.\nThese files are important for building the frontend and making the application functional for managing products.\nIn the index.html file, paste the following code: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Product Manager\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: \u0026#39;Roboto\u0026#39;, Arial, sans-serif; background-color: #f8f9fa; margin: 0; padding: 0; } .container { max-width: 800px; margin: 40px auto; background: #ffffff; padding: 20px; border-radius: 10px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); } h1 { text-align: center; color: #333333; text-transform: uppercase; } .product-form { background: #f4f4f4; padding: 20px; border-radius: 8px; margin-bottom: 20px; } .product-form h3 { margin-bottom: 15px; color: #555555; } .product-form input { width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid #cccccc; border-radius: 5px; font-size: 14px; } .product-form button { width: 100%; padding: 10px; background: #28a745; color: #ffffff; border: none; margin: 15px 0; border-radius: 5px; font-size: 16px; cursor: pointer; transition: background-color 0.3s ease; } .product-form button:hover { background: #218838; } .product-list { margin-top: 20px; } .product-list h3 { font-size: 25px; color: #555555; margin: 35px 0 20px 0; text-align: center; text-transform: uppercase; } .product-list table { width: 100%; border-collapse: collapse; margin-top: 10px; background: #ffffff; overflow: hidden; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } .product-list th { background: #545454; color: #ffffff; padding: 12px; text-align: center; font-size: 14px; border: 1px solid #fff; } .product-list td { border: 1px solid #c9c9c9; padding: 10px; font-size: 14px; color: #333333; text-align: center; } .product-list tr:nth-child(odd) { background-color: #f8f9fa; } .product-list tr:nth-child(even) { background-color: #ffffff; } .product-list td:last-child { text-align: center; } .product-list button { padding: 5px 10px; color: #ffffff; border: none; border-radius: 3px; font-size: 12px; cursor: pointer; transition: background-color 0.3s ease; } .product-list .delete-button { background: #dc3545; padding: 10px; color: #ffffff; border: none; margin: 15px 0; border-radius: 5px; font-size: 16px; cursor: pointer; transition: background-color 0.3s ease; } .product-list .delete-button:hover { background: #c82333; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Product Manager\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;product-form\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Add or Update Product\u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;productId\u0026#34; placeholder=\u0026#34;Product ID\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;productName\u0026#34; placeholder=\u0026#34;Product Name\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;productPrice\u0026#34; placeholder=\u0026#34;Product Price\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;addOrUpdateProduct()\u0026#34;\u0026gt;Add or Update Product\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-list\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Product List\u0026lt;/h3\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;ID\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Price\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Actions\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody id=\u0026#34;productTableBody\u0026#34;\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; In the app.js file, paste the following code: const apiUrl = \u0026#34;https://m6leha6hvk.execute-api.us-east-1.amazonaws.com/prod\u0026#34;; async function getAllProducts() { try { const response = await fetch(`${apiUrl}/products`); const data = await response.json(); renderProducts(data.products || []); } catch (error) { console.error(\u0026#34;Error fetching products:\u0026#34;, error); } } async function addOrUpdateProduct() { const id = document.getElementById(\u0026#34;productId\u0026#34;).value; const name = document.getElementById(\u0026#34;productName\u0026#34;).value; const price = document.getElementById(\u0026#34;productPrice\u0026#34;).value; if (!id || !name || !price) { alert(\u0026#34;Please fill all fields\u0026#34;); return; } const product = { id, name, price: Number(price) }; const existingProduct = await fetch(`${apiUrl}/product?id=${id}`).then(res =\u0026gt; res.ok ? res.json() : null); try { if (existingProduct \u0026amp;\u0026amp; existingProduct.product) { const response = await fetch(`${apiUrl}/product`, { method: \u0026#34;PUT\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(product), }); const result = await response.json(); alert(result.message || \u0026#34;Product updated successfully !\u0026#34;); } else { const response = await fetch(`${apiUrl}/products`, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(product), }); const result = await response.json(); alert(result.message || \u0026#34;Product added successfully !\u0026#34;); } getAllProducts(); } catch (error) { console.error(\u0026#34;Error saving product:\u0026#34;, error); } } async function deleteProduct(productId) { if (!confirm(\u0026#34;Are you sure you want to delete this product?\u0026#34;)) return; try { const response = await fetch(`${apiUrl}/product?id=${productId}`, { method: \u0026#34;DELETE\u0026#34;, }); const result = await response.json(); if (response.ok) { alert(result.message || \u0026#34;Product deleted successfully !\u0026#34;); getAllProducts(); } else { alert(result.message || \u0026#34;Failed to delete product\u0026#34;); } } catch (error) { console.error(\u0026#34;Error deleting product:\u0026#34;, error); } } function renderProducts(products) { const tableBody = document.getElementById(\u0026#34;productTableBody\u0026#34;); tableBody.innerHTML = \u0026#34;\u0026#34;; products.forEach((product) =\u0026gt; { const row = document.createElement(\u0026#34;tr\u0026#34;); row.innerHTML = ` \u0026lt;td\u0026gt;${product.id}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${product.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${product.price}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;button class=\u0026#34;delete-button\u0026#34; onclick=\u0026#34;deleteProduct(\u0026#39;${product.id}\u0026#39;)\u0026#34;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; `; tableBody.appendChild(row); }); } window.onload = () =\u0026gt; { getAllProducts(); }; We have completed uploading the essential project files. Next we will create S3. In the line var apiUrl = \u0026ldquo;https://m6leha6hvk.execute-api.us-east-1.amazonaws.com/prod\"; replace https://m6leha6hvk.execute-api.us-east-1.amazonaws.com/prod with the Invoke URL from your API Gateway deployed in section 5.2. DeployAPI. This URL connects your UI to the server, allowing your application to perform actions such as adding, updating, retrieving, and deleting data efficiently.\n"
},
{
	"uri": "https://tai10012003.github.io/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Serverless is a cloud computing model where AWS manages the infrastructure, allowing developers to concentrate on writing code and building applications efficiently. It simplifies development by removing the need for server setup and maintenance.\nFeatures of the Serverless model:\nNo Server Management: AWS handles infrastructure, so developers can focus solely on application logic. Pay-as-You-Go: Costs are based only on usage, including Lambda executions, S3 storage, API Gateway requests, and DynamoDB operations. Automatic Scaling: Services scale up or down automatically to match demand, ensuring cost efficiency and consistent performance. Fast Deployment: Pre-configured AWS services speed up the development process. Ideal Use Cases: Web and mobile applications, lightweight APIs, real-time or batch processing, MVPs, and cost-sensitive projects. Main components of the application:\nAWS DynamoDB: A fully managed NoSQL database for storing and retrieving product data with high performance and scalability. IAM Role for Lambda and DynamoDB: Manages access permissions for AWS resources to ensure secure interactions between Lambda and DynamoDB. AWS Lambda: Serves as the backend to handle CRUD operations. Written in Python, these functions interact with DynamoDB to manage product data efficiently. AWS API Gateway: Acts as a bridge between the frontend and backend by creating RESTful APIs. Offers secure and manageable endpoints for frontend interactions. AWS S3: Stores static assets for the user interface, such as HTML, CSS, and JavaScript. Simple, cost-effective, and highly reliable storage for hosting the front-end. "
},
{
	"uri": "https://tai10012003.github.io/7-testresults/7.1-postman/",
	"title": "Using Postman",
	"tags": [],
	"description": "",
	"content": "Postman is a popular tool used to test APIs. Follow the steps below to test your deployed API:\nOpen Postman: Make sure you followed section 2. Preparation to download and install Postman. If you have already downloaded and installed it, open it.\nCreate New Request: Click Blank collection, name your new collection.\nSet the URL: In the URL field, copy the Invoke URL from your deployed API Gateway. For example: https://\u0026lt;your-api-id\u0026gt;.execute-api.\u0026lt;region\u0026gt;.amazonaws.com/\u0026lt;stage\u0026gt;/\u0026lt;endpoint\u0026gt;\nShow product list: Select the GET method.\nPaste the copied URL and add /products.\nClick Send.\nResult: Display product list (currently no products)\nAdd a new product: Select the POST method.\nPaste the copied URL and add /products.\nNavigate to Body, select raw and select JSON.\nFill in product information:\n{ \u0026#34;id\u0026#34;: \u0026#34;101\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Laptop Levono\u0026#34;,\r\u0026#34;price\u0026#34;: \u0026#34;50000\u0026#34;,\r} Click Send.\nResult: Displays a message that the new product was successfully added.\nContinue adding new products: { \u0026#34;id\u0026#34;: \u0026#34;102\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Laptop HP\u0026#34;,\r\u0026#34;price\u0026#34;: \u0026#34;35000\u0026#34;,\r} Result: Displays a message that the new product was successfully added. Display product list after adding: do the same as step 4. Get product information by ID: Select the GET method.\nPaste the copied URL and add /product?id={id}.\nClick Send.\nResult: Display product information by ID.\nUpdate product information: Select the PUT method.\nPaste the copied URL and add /product?id={id}.\nNavigate to Body, select raw and select JSON.\nEdit product information:\n{ \u0026#34;id\u0026#34;: \u0026#34;102\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Laptop HP\u0026#34;,\r\u0026#34;price\u0026#34;: \u0026#34;35000\u0026#34;,\r} Click Send.\nResult: Displays a message that the product has been successfully updated.\nDisplay product list after update: do the same as step 4. Delete product information: Select the DELETE method.\nPaste the copied URL and add /product?id={id}.\nClick Send.\nResult: Displays a message that the product has been successfully deleted.\nDisplay product list after deletion: do the same as step 4. We have completed testing the results using Postman. Next we will test the results using the website hosted on S3. "
},
{
	"uri": "https://tai10012003.github.io/4-lambdafunc/4.2-createlambda/",
	"title": "Create Lambda Function",
	"tags": [],
	"description": "",
	"content": "Create Lambda Function In this step, we will create a Lambda Function that handles all the CRUD (Create, Read, Update, Delete) operations for the application. The Lambda Function will serve as the backend, processing requests received from the API Gateway and interacting with S3 to manage product data.\nSearch for Lambda in the search bar and click on Lambda. In the AWS Lambda console, click on the Create a function button. In the Create a function. Provide the following details: Choose \u0026ldquo;Author from scratch\u0026rdquo;.\nFunction name: Enter a name for your function (e.g. ProductCRUDFunction)\nRuntime: Select Python 3.12\nArchitecture: Select x86_64.\nPermissions: Under Execution role section, select Use an existing role, the system will display the Existing Role section, select the IAM Role name that you created earlier in section 4.1. Create IAM Role for Lambda and DynamoDB\nClick Create function button to proceed.\nAfter creating the function, a confirmation message will appear at the top of the screen: the function was successfully created.\nIn the ProductCRUDFunction section created, scroll down to the Code source section.\nIn the source code box:\nClick to edit the code inline.\nReplace the default lambda_function.py content with the following code:\nimport json import boto3 from decimal import Decimal dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;ProductsTable\u0026#39;) class DecimalEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, Decimal): return float(obj) return super(DecimalEncoder, self).default(obj) def lambda_handler(event, context): path = event.get(\u0026#34;path\u0026#34;) http_method = event.get(\u0026#34;httpMethod\u0026#34;) body = json.loads(event[\u0026#34;body\u0026#34;]) if event.get(\u0026#34;body\u0026#34;) else None query_params = event.get(\u0026#34;queryStringParameters\u0026#34;) if path == \u0026#34;/products\u0026#34; and http_method == \u0026#34;GET\u0026#34;: return get_all_products() elif path == \u0026#34;/products\u0026#34; and http_method == \u0026#34;POST\u0026#34;: return add_product(body) elif path == \u0026#34;/product\u0026#34; and http_method == \u0026#34;GET\u0026#34;: return get_product(query_params.get(\u0026#34;id\u0026#34;) if query_params else None) elif path == \u0026#34;/product\u0026#34; and http_method == \u0026#34;PUT\u0026#34;: return update_product(body) elif path == \u0026#34;/product\u0026#34; and http_method == \u0026#34;DELETE\u0026#34;: return delete_product(query_params.get(\u0026#34;id\u0026#34;) if query_params else None) else: return build_response(404, {\u0026#34;message\u0026#34;: \u0026#34;Endpoint not found\u0026#34;}) def get_all_products(): try: response = table.scan() products = response.get(\u0026#34;Items\u0026#34;, []) for product in products: product[\u0026#34;price\u0026#34;] = float(product[\u0026#34;price\u0026#34;]) return build_response(200, {\u0026#34;products\u0026#34;: products}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def add_product(product): required_fields = {\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;price\u0026#34;} if not product or not required_fields.issubset(product): return build_response(400, {\u0026#34;message\u0026#34;: \u0026#34;Missing required fields\u0026#34;}) try: product[\u0026#34;price\u0026#34;] = Decimal(str(product[\u0026#34;price\u0026#34;])) table.put_item(Item=product) return build_response(201, {\u0026#34;message\u0026#34;: \u0026#34;Product added successfully !\u0026#34;, \u0026#34;product\u0026#34;: product}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def get_product(product_id): if not product_id: return build_response(400, {\u0026#34;message\u0026#34;: \u0026#34;Product ID is required\u0026#34;}) try: response = table.get_item(Key={\u0026#34;id\u0026#34;: product_id}) if \u0026#34;Item\u0026#34; in response: product = response[\u0026#34;Item\u0026#34;] product[\u0026#34;price\u0026#34;] = float(product[\u0026#34;price\u0026#34;]) return build_response(200, {\u0026#34;product\u0026#34;: product}) else: return build_response(404, {\u0026#34;message\u0026#34;: \u0026#34;Product not found\u0026#34;}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def update_product(updated_product): if not updated_product or \u0026#34;id\u0026#34; not in updated_product: return build_response(400, {\u0026#34;message\u0026#34;: \u0026#34;Product ID is required\u0026#34;}) try: table.update_item( Key={\u0026#34;id\u0026#34;: updated_product[\u0026#34;id\u0026#34;]}, UpdateExpression=\u0026#34;SET #n = :name, price = :price\u0026#34;, ExpressionAttributeNames={\u0026#34;#n\u0026#34;: \u0026#34;name\u0026#34;}, ExpressionAttributeValues={ \u0026#34;:name\u0026#34;: updated_product[\u0026#34;name\u0026#34;], \u0026#34;:price\u0026#34;: Decimal(str(updated_product[\u0026#34;price\u0026#34;])), } ) return build_response(200, {\u0026#34;message\u0026#34;: \u0026#34;Product updated successfully !\u0026#34;}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def delete_product(product_id): if not product_id: return build_response(400, {\u0026#34;message\u0026#34;: \u0026#34;Product ID is required\u0026#34;}) try: table.delete_item(Key={\u0026#34;id\u0026#34;: product_id}) return build_response(200, {\u0026#34;message\u0026#34;: \u0026#34;Product deleted successfully !\u0026#34;}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def build_response(status_code, body): return { \u0026#34;statusCode\u0026#34;: status_code, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET, POST, PUT, DELETE, OPTIONS\u0026#34;, }, \u0026#34;body\u0026#34;: json.dumps(body, cls=DecimalEncoder), } Click Deploy (Ctrl+Shift+U) to save the function. After saving, the system will display the message: Successfully updated the function ProductCRUDFunction. We have completed creating Lambda Function. "
},
{
	"uri": "https://tai10012003.github.io/6-s3setup/6.2-create-s3/",
	"title": "Create S3",
	"tags": [],
	"description": "",
	"content": "Create S3 Bucket In this step, we will create an S3 bucket to store the static content of the website, such as HTML, CSS, and JavaScript files. The S3 bucket will be used to host the website and enable static website hosting in the next steps. The actual file uploads will be covered in the section 6.3. Load Data.\nSearch for S3 in the search bar and click on S3. In the S3 console, click on the Create bucket button. In the Create bucket, provide the following details: In the General configuration section:\nBucket type: Select General purpose.\nBucket Name: Enter a name for your bucket, such as my-product-app.\nIn the Block Public Access settings for this bucket section:\nUncheck Block all public access.\nTurning off block all public access might result in this bucket and the objects within becoming public: Select I acknowledge that the current settings might result in this bucket and the objects within becoming public.\nScroll down and Click Create bucket button to proceed.\nAfter creating the bucket, a confirmation message will appear at the top of the screen: Successfully created bucket. In the my-product-app section created, navigate to the Properties section. Scroll down to the Static website hosting section, click Edit button. In the Edit static website hosting section, provide the following details: Static website hosting: Select Enable.\nIndex document: Enter index.html.\nError document: Enter error.html (or leave blank) as the Error document.\nScroll down and click Save changes button.\nIn the my-product-app section, navigate to the Permisstions section. Scroll down to the Bucket policy section, click Edit button. In the Bucket policy section, provide the following details: In the Policy section, add the following policy to allow public read access:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::my-product-app/*\u0026#34; } ] } Replace my-product-app with your correct bucket name.\nScroll down and click Save changes button. We have completed creating S3. Next we will load data. "
},
{
	"uri": "https://tai10012003.github.io/5-apigateway/5.2-deployapi/",
	"title": "Deploy API",
	"tags": [],
	"description": "",
	"content": "Deploy API After creating the RESTful API, we will deploy it to make the endpoints publicly accessible. This involves creating a new Stage (e.g., prod), which allows the API Gateway to process requests and route them to the connected Lambda Function. This step ensures the API is ready for use and integration with the application.\nIn the Resources section, click Deploy API button. In the Deploy API section, Provide the following details: Stage: Select New stage.\nStage Name: Enter a name for your stage (e.g. prod)\nDescription: Add a deployment description (optional).\nClick Deploy button.\nAfter creating the stage, a confirmation message will appear at the top of the screen: Successfully created deployment for ProductAPI. Note the Invoke URL for the deployed API (e.g., https://{api-id}.execute-api.{region}.amazonaws.com/prod). We have completed the API deployment. "
},
{
	"uri": "https://tai10012003.github.io/2-preparation/",
	"title": "Preparation Steps",
	"tags": [],
	"description": "",
	"content": "AWS Accounts You need an AWS account to do this lab. If you don\u0026rsquo;t have one, please sign up for an AWS account.\nTo learn how to create an AWS account, you can refer to:\nCreating your first AWS account Basic files File index.html: User interface.\nFile app.js: Send request to API Gateway.\nNecessary tools Source code editor:\nVisual Studio Code â€“ A free, powerful, and extensible source code editor, ideal for serverless application development. Use it to build the user interface in index.html and handle API requests in app.js to communicate with API Gateway.\nInstall Visual Studio Code from Visual Studio Code official website.\nAPI Testing Tools:\nPostman â€“ A user-friendly tool for testing API Gateway by sending requests and validating responses from the serverless application.\nInstall Postman from Postman official website.\nActivate services AWS DynamoDB: Provide a fast and scalable NoSQL database for managing and storing application data.\nIAM Role for Lambda and DynamoDB: IAM Role to allow Lambda Function to perform operations on DynamoDB.\nAWS Lambda: Execute backend code to handle application logic and interact with the database.\nAmazon API Gateway: Manage RESTful API endpoints to connect the frontend with backend services.\nAWS S3: Store and serve static content such as HTML, CSS, and JavaScript for the application interface.\n"
},
{
	"uri": "https://tai10012003.github.io/7-testresults/7.2-webs3/",
	"title": "Using Website Hosted on S3",
	"tags": [],
	"description": "",
	"content": "Using Website Hosted on S3 In this step, we will test the website hosted on S3 to ensure it functions correctly and integrates seamlessly with the deployed API Gateway and Lambda Function. The goal is to verify that the frontend interacts properly with the backend for all CRUD operations.\nLocate the bucket where your website files are hosted, go to the Properties tab and find the Static website hosting section, copy the website endpoint URL and open it in your browser. After copying the website endpoint URL and opening it in your browser, the interface will appear, showing all the features needed for interaction. The interface provides full functionality, making it easy to test and use the application. Add a new product: Use the form on the page to input details like product ID, product name and product price.\nClick the Add Product button.\nResult: Displays a message that the new product was successfully added.\nDisplay product list after adding. Update product information: Update the product details in the form like product ID, product name and product price.\nClick the Update Product button.\nResult: Displays a message that the product has been successfully updated.\nDisplay product list after update. Delete product information: Click the Delete button in the Actions column.\nConfirm the deletion.\nResult: Displays a message that the product has been successfully deleted.\nDisplay product list after deletion. Check if the data has been saved in DynamoDB. Congratulations, you have completed the tutorial on setting up and testing your application with S3, Lambda, API Gateway and DynamoDB. Make sure to clean up any unused resources to avoid unnecessary charges.\n"
},
{
	"uri": "https://tai10012003.github.io/3-createdynamodb/",
	"title": "Create Table DynamoDB",
	"tags": [],
	"description": "",
	"content": "Create Table DynamoDB In this step, we will create a DynamoDB table to store all the product data for the application. The table will serve as the primary database, enabling CRUD (Create, Read, Update, Delete) operations through the Lambda Function. Each product will be stored as an item in the table, with attributes such as ID, name, and price. The table will be configured to support efficient data retrieval and interaction through API Gateway and Lambda.\nFrom the AWS Management console, search for DynamoDB in the search bar and click on DynamoDB. In the AWS DynamoDB console, click on the Create table button. In the Create table. Provide the following details: Table name: Table name: Enter a name for your table (e.g. ProductsTable)\nPartition Key: Enter the key named id.\nKey type: Select String for Partition key.\nScroll down and click Create table button to proceed.\nAfter creating the table, a confirmation message will appear at the top of the screen: the table was successfully created. We have completed creating table for DynamoDB. "
},
{
	"uri": "https://tai10012003.github.io/6-s3setup/6.3-load-data/",
	"title": "Load Data",
	"tags": [],
	"description": "",
	"content": "Load Data In this step, we will upload the static website files (HTML, CSS, JavaScript) into the S3 bucket created in the previous step. This will enable the S3 bucket to serve as a static website hosting platform for the application.\nEnsure you have the following files ready: index.html: The main file of your website.\napp.js: Contains the JavaScript code to interact with the API Gateway.\nIn the my-product-app section, navigate to the Objects section, then click the Upload button. In the Upload section: Click Add files button and select your static files (e.g., index.html, app.js, etc.).\nIf you have multiple files organized in folders, click Add folder.\nSelect the index.js file and the app.js file from your computer saved. Scroll down and click Upload to start the process. After uploading the 2 files, a confirmation message will appear at the top of the screen: upload succeeded. In the my-product-app section, navigate to the Properties section. Scroll down to the Static website hosting section. Note: the Bucket website endpoint URL to use to check the results on the website (e.g., http://my-website-static-bucket.s3-website-us-east-1.amazonaws.com). We have completed the data loading. "
},
{
	"uri": "https://tai10012003.github.io/4-lambdafunc/",
	"title": "Lambda Function",
	"tags": [],
	"description": "",
	"content": "In this step, we will create an IAM Role to grant Lambda the necessary permissions to interact with DynamoDB. We will then set up a Lambda Function to handle the logic for our application. This function will act as a core service, integrating with other AWS components.\nContent 4.1. Create IAM Role for Lambda and DynamoDB\n4.2. Create Lambda Function\n"
},
{
	"uri": "https://tai10012003.github.io/5-apigateway/",
	"title": "API Gateway",
	"tags": [],
	"description": "",
	"content": "In this step, we will set up the API Gateway to link the user interface to the server, enabling interaction between the web application and the Lambda Function. The API Gateway will serve as a connector, processing HTTP requests and sending them to the correct Lambda Function. Finally, we will deploy the API to make it available for testing and use.\nContent 5.1. Create API Gateway\n5.2. Deploy API\n"
},
{
	"uri": "https://tai10012003.github.io/6-s3setup/",
	"title": "S3 Setup",
	"tags": [],
	"description": "",
	"content": "In this step, we will create an S3 bucket to store the static content of the website, including HTML, CSS, and JavaScript files. Then, we will upload the website data to S3 to enable static website hosting.\nContent 6.1. Essential project files\n6.2. Create S3\n6.3. Load data\n"
},
{
	"uri": "https://tai10012003.github.io/7-testresults/",
	"title": "Test Results",
	"tags": [],
	"description": "",
	"content": "In this step, we will verify that our application is functioning correctly by testing the deployed API and the website hosted on S3. These tests will ensure the API endpoints and the user interface are working for performing CRUD operations.\nContent 7.1. Using Postman\n7.2. Using Website Hosted on S3\n"
},
{
	"uri": "https://tai10012003.github.io/8-cleanup/",
	"title": "Clean Up Resources",
	"tags": [],
	"description": "",
	"content": "We will take the following steps to delete the resources we created in this exercise.\nDelete DynamoDB In the AWS DynamoDB console, navigate to the Tables.\nSelect the table to delete, then click Delete button.\nIn the Delete table, enter in the box: confirm and click Delete button.\nAfter deleting the table, a confirmation message will appear at the top of the screen: the table was deleted successfully.\nDelete S3 Delete Object\nIn the AWS S3 console, access my-product-app section.\nSelect 2 files: index.html and app.js, then click Delete button.\nIn the Delete Objects, enter in the box: permanently delete and click Delete objects button.\nAfter deleting the object, a confirmation message will appear at the top of the screen: the object was deleted successfully.\nDelete Bucket\nIn the AWS S3 console, select my-product-app section and click Delete button.\nIn the Delete bucket, enter in the bucket name box: my-product-app and click Delete Bucket button.\nAfter deleting the bucket, a confirmation message will appear at the top of the screen: the bucket was deleted successfully.\nDelete Lambda In the AWS Lambda console, navigate to the Functions.\nSelect the function to delete, then click Actions button and click Delete button.\nIn the Delete 1 functions, enter in the box: delete and click Delete button.\nDelete API Gateway In the AWS API Gateway console, navigate to the APIs.\nSelect the API to delete, then click Delete button.\nIn the Delete API, enter in the box: confirm and click Delete button.\nAfter deleting the API, a confirmation message will appear at the top of the screen: the API was deleted successfully.\n"
},
{
	"uri": "https://tai10012003.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tai10012003.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]