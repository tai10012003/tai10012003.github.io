[
{
	"uri": "https://tai10012003.github.io/vi/",
	"title": "Xây dựng website quản lý sản phẩm serverless cơ bản với các dịch vụ của AWS",
	"tags": [],
	"description": "",
	"content": "Xây dựng Website quản lý sản phẩm serverless cơ bản với các dịch vụ của AWS Tổng quan Trong phòng thí nghiệm này, chúng ta sẽ học cách tạo một website quản lý sản phẩm serverless đơn giản bằng các dịch vụ của AWS như S3, Lambda, API Gateway và DynamoDB. Ứng dụng sẽ bao gồm các tính năng CRUD (Tạo, Đọc, Cập nhật, Xóa) để quản lý sản phẩm. Với phương pháp serverless, chúng ta sẽ không cần phải quản lý máy chủ, cho phép chúng ta tập trung vào việc xây dựng ứng dụng của mình trong khi vẫn giữ chi phí thấp và dễ dàng mở rộng quy mô.\nNội dung Giới thiệu Chuẩn bị Tạo bảng DynamoDB Hàm Lambda API Gateway Thiết lập S3 Kiểm tra kết quả Dọn dẹp tài nguyên "
},
{
	"uri": "https://tai10012003.github.io/vi/6-s3setup/6.1-essentialprojectfiles/",
	"title": "Các tệp dự án cần thiết",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ tạo các tệp chính cần thiết cho giao diện người dùng của ứng dụng. Bao gồm:\nindex.html: Tệp này thiết lập cấu trúc và thiết kế giao diện người dùng. Tệp này bao gồm biểu mẫu để thêm hoặc cập nhật sản phẩm, danh sách để hiển thị sản phẩm và các nút để chỉnh sửa hoặc xóa sản phẩm. CSS đơn giản được sử dụng để làm cho trang trông sạch sẽ và hiện đại.\napp.js: Tệp này chứa mã JavaScript để xử lý các hành động của sản phẩm như thêm, cập nhật, tìm nạp và xóa thông qua API Gateway. Tệp này cũng cập nhật giao diện người dùng dựa trên các hành động của người dùng.\nCác tệp này rất quan trọng để xây dựng giao diện người dùng và giúp ứng dụng hoạt động để quản lý sản phẩm.\nTrong tệp index.html, hãy dán mã sau: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Product Manager\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: \u0026#39;Roboto\u0026#39;, Arial, sans-serif; background-color: #f8f9fa; margin: 0; padding: 0; } .container { max-width: 800px; margin: 40px auto; background: #ffffff; padding: 20px; border-radius: 10px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); } h1 { text-align: center; color: #333333; text-transform: uppercase; } .product-form { background: #f4f4f4; padding: 20px; border-radius: 8px; margin-bottom: 20px; } .product-form h3 { margin-bottom: 15px; color: #555555; } .product-form input { width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid #cccccc; border-radius: 5px; font-size: 14px; } .product-form button { width: 100%; padding: 10px; background: #28a745; color: #ffffff; border: none; margin: 15px 0; border-radius: 5px; font-size: 16px; cursor: pointer; transition: background-color 0.3s ease; } .product-form button:hover { background: #218838; } .product-list { margin-top: 20px; } .product-list h3 { font-size: 25px; color: #555555; margin: 35px 0 20px 0; text-align: center; text-transform: uppercase; } .product-list table { width: 100%; border-collapse: collapse; margin-top: 10px; background: #ffffff; overflow: hidden; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } .product-list th { background: #545454; color: #ffffff; padding: 12px; text-align: center; font-size: 14px; border: 1px solid #fff; } .product-list td { border: 1px solid #c9c9c9; padding: 10px; font-size: 14px; color: #333333; text-align: center; } .product-list tr:nth-child(odd) { background-color: #f8f9fa; } .product-list tr:nth-child(even) { background-color: #ffffff; } .product-list td:last-child { text-align: center; } .product-list button { padding: 5px 10px; color: #ffffff; border: none; border-radius: 3px; font-size: 12px; cursor: pointer; transition: background-color 0.3s ease; } .product-list .delete-button { background: #dc3545; padding: 10px; color: #ffffff; border: none; margin: 15px 0; border-radius: 5px; font-size: 16px; cursor: pointer; transition: background-color 0.3s ease; } .product-list .delete-button:hover { background: #c82333; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Product Manager\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;product-form\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Add or Update Product\u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;productId\u0026#34; placeholder=\u0026#34;Product ID\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;productName\u0026#34; placeholder=\u0026#34;Product Name\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;productPrice\u0026#34; placeholder=\u0026#34;Product Price\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;addOrUpdateProduct()\u0026#34;\u0026gt;Add or Update Product\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-list\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Product List\u0026lt;/h3\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;ID\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Price\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Actions\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody id=\u0026#34;productTableBody\u0026#34;\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Trong tệp app.js, dán đoạn mã sau: const apiUrl = \u0026#34;https://m6leha6hvk.execute-api.us-east-1.amazonaws.com/prod\u0026#34;; async function getAllProducts() { try { const response = await fetch(`${apiUrl}/products`); const data = await response.json(); renderProducts(data.products || []); } catch (error) { console.error(\u0026#34;Error fetching products:\u0026#34;, error); } } async function addOrUpdateProduct() { const id = document.getElementById(\u0026#34;productId\u0026#34;).value; const name = document.getElementById(\u0026#34;productName\u0026#34;).value; const price = document.getElementById(\u0026#34;productPrice\u0026#34;).value; if (!id || !name || !price) { alert(\u0026#34;Please fill all fields\u0026#34;); return; } const product = { id, name, price: Number(price) }; const existingProduct = await fetch(`${apiUrl}/product?id=${id}`).then(res =\u0026gt; res.ok ? res.json() : null); try { if (existingProduct \u0026amp;\u0026amp; existingProduct.product) { const response = await fetch(`${apiUrl}/product`, { method: \u0026#34;PUT\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(product), }); const result = await response.json(); alert(result.message || \u0026#34;Product updated successfully !\u0026#34;); } else { const response = await fetch(`${apiUrl}/products`, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(product), }); const result = await response.json(); alert(result.message || \u0026#34;Product added successfully !\u0026#34;); } getAllProducts(); } catch (error) { console.error(\u0026#34;Error saving product:\u0026#34;, error); } } async function deleteProduct(productId) { if (!confirm(\u0026#34;Are you sure you want to delete this product?\u0026#34;)) return; try { const response = await fetch(`${apiUrl}/product?id=${productId}`, { method: \u0026#34;DELETE\u0026#34;, }); const result = await response.json(); if (response.ok) { alert(result.message || \u0026#34;Product deleted successfully !\u0026#34;); getAllProducts(); } else { alert(result.message || \u0026#34;Failed to delete product\u0026#34;); } } catch (error) { console.error(\u0026#34;Error deleting product:\u0026#34;, error); } } function renderProducts(products) { const tableBody = document.getElementById(\u0026#34;productTableBody\u0026#34;); tableBody.innerHTML = \u0026#34;\u0026#34;; products.forEach((product) =\u0026gt; { const row = document.createElement(\u0026#34;tr\u0026#34;); row.innerHTML = ` \u0026lt;td\u0026gt;${product.id}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${product.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${product.price}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;button class=\u0026#34;delete-button\u0026#34; onclick=\u0026#34;deleteProduct(\u0026#39;${product.id}\u0026#39;)\u0026#34;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; `; tableBody.appendChild(row); }); } window.onload = () =\u0026gt; { getAllProducts(); }; Chúng tôi đã hoàn tất việc tải lên các tệp dự án cần thiết. Tiếp theo, chúng tôi sẽ tạo S3. Trong dòng var apiUrl = \u0026ldquo;https://m6leha6hvk.execute-api.us-east-1.amazonaws.com/prod\"; thay thế https://m6leha6hvk.execute-api.us-east-1.amazonaws.com/prod bằng Invoke URL từ API Gateway của bạn được triển khai trong phần 5.2. DeployAPI. URL này kết nối UI của bạn với máy chủ, cho phép ứng dụng của bạn thực hiện các hành động như thêm, cập nhật, truy xuất và xóa dữ liệu một cách hiệu quả.\n"
},
{
	"uri": "https://tai10012003.github.io/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Serverless là mô hình điện toán đám mây trong đó AWS quản lý cơ sở hạ tầng, cho phép các nhà phát triển tập trung vào việc viết mã và xây dựng ứng dụng hiệu quả. Mô hình này đơn giản hóa quá trình phát triển bằng cách loại bỏ nhu cầu thiết lập và bảo trì máy chủ.\nCác tính năng của mô hình Serverless:\nKhông quản lý máy chủ: AWS xử lý cơ sở hạ tầng, do đó các nhà phát triển có thể tập trung hoàn toàn vào logic ứng dụng. Trả tiền khi sử dụng: Chi phí chỉ dựa trên mức sử dụng, bao gồm thực thi Lambda, lưu trữ S3, yêu cầu API Gateway và hoạt động DynamoDB. Tự động mở rộng quy mô: Các dịch vụ tự động tăng hoặc giảm quy mô để phù hợp với nhu cầu, đảm bảo hiệu quả về chi phí và hiệu suất nhất quán. Triển khai nhanh: Các dịch vụ AWS được cấu hình sẵn giúp tăng tốc quá trình phát triển. Các trường hợp sử dụng lý tưởng: Ứng dụng web và di động, API nhẹ, xử lý theo thời gian thực hoặc theo lô, MVP và các dự án nhạy cảm về chi phí. Các thành phần chính của ứng dụng:\nAWS DynamoDB: Cơ sở dữ liệu NoSQL được quản lý hoàn toàn để lưu trữ và truy xuất dữ liệu sản phẩm với hiệu suất và khả năng mở rộng cao. IAM Role cho Lambda và DynamoDB: Quản lý quyền truy cập cho các tài nguyên AWS để đảm bảo tương tác an toàn giữa Lambda và DynamoDB. AWS Lambda: Hoạt động như phần phụ trợ để xử lý các hoạt động CRUD. Được viết bằng Python, các hàm này tương tác với DynamoDB để quản lý dữ liệu sản phẩm một cách hiệu quả. AWS API Gateway: Hoạt động như một cầu nối giữa giao diện người dùng và phần phụ trợ bằng cách tạo API RESTful. Cung cấp các điểm cuối an toàn và có thể quản lý được cho các tương tác giao diện người dùng. AWS S3: Lưu trữ các tài sản tĩnh cho giao diện người dùng, chẳng hạn như HTML, CSS và JavaScript. Lưu trữ đơn giản, tiết kiệm chi phí và có độ tin cậy cao để lưu trữ giao diện người dùng. "
},
{
	"uri": "https://tai10012003.github.io/vi/7-testresults/7.1-postman/",
	"title": "Sử dụng Postman",
	"tags": [],
	"description": "",
	"content": "Postman là một công cụ phổ biến được sử dụng để kiểm tra API. Thực hiện theo các bước dưới đây để kiểm tra API đã triển khai của bạn:\nMở Postman: Đảm bảo bạn đã làm theo phần 2. Các bước chuẩn bị để tải xuống và cài đặt Postman. Nếu bạn đã tải xuống và cài đặt, hãy mở nó.\nCreate New Request: Nhấp vào Blank collection, đặt tên cho bộ sưu tập mới của bạn.\nĐặt URL: Trong trường URL, sao chép Invoke URL từ API Gateway đã triển khai của bạn. Ví dụ: https://\u0026lt;your-api-id\u0026gt;.execute-api.\u0026lt;region\u0026gt;.amazonaws.com/\u0026lt;stage\u0026gt;/\u0026lt;endpoint\u0026gt;\nHiển thị danh sách sản phẩm: Chọn phương thức GET.\nDán URL đã sao chép và thêm /products.\nNhấp vào Send.\nKết quả: Hiển thị danh sách sản phẩm (hiện không có sản phẩm nào)\nThêm sản phẩm mới: Chọn phương thức POST.\nDán URL đã sao chép và thêm /products.\nĐiều hướng đến Body, chọn raw và chọn JSON.\nĐiền thông tin sản phẩm:\n{\r\u0026#34;id\u0026#34;: \u0026#34;101\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Laptop Levono\u0026#34;,\r\u0026#34;price\u0026#34;: \u0026#34;50000\u0026#34;,\r} Nhấp vào Send.\nKết quả: Hiển thị thông báo rằng sản phẩm mới đã được thêm thành công.\nTiếp tục thêm sản phẩm mới: {\r\u0026#34;id\u0026#34;: \u0026#34;102\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Laptop HP\u0026#34;,\r\u0026#34;price\u0026#34;: \u0026#34;35000\u0026#34;,\r} Kết quả: Hiển thị thông báo rằng sản phẩm mới đã được thêm thành công. Hiển thị danh sách sản phẩm sau khi thêm: thực hiện tương tự như bước 4. Lấy thông tin sản phẩm theo ID: Chọn phương thức GET.\nDán URL đã sao chép và thêm /product?id={id}.\nNhấp vào Send.\nKết quả: Hiển thị thông tin sản phẩm theo ID.\nCập nhật thông tin sản phẩm: Chọn phương thức PUT.\nDán URL đã sao chép và thêm /product?id={id}.\nĐiều hướng đến Body, chọn raw và chọn JSON.\nChỉnh sửa thông tin sản phẩm:\n{\r\u0026#34;id\u0026#34;: \u0026#34;102\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Laptop HP\u0026#34;,\r\u0026#34;price\u0026#34;: \u0026#34;35000\u0026#34;,\r} Nhấp vào Send.\nKết quả: Hiển thị thông báo sản phẩm đã được cập nhật thành công.\nHiển thị danh sách sản phẩm sau khi cập nhật: thực hiện tương tự như bước 4. Xóa thông tin sản phẩm: Chọn phương thức XÓA.\nDán URL đã sao chép và thêm /product?id={id}.\nNhấp vào Send.\nKết quả: Hiển thị thông báo sản phẩm đã được xóa thành công.\nHiển thị danh sách sản phẩm sau khi xóa: thực hiện tương tự như bước 4. Chúng ta đã hoàn tất việc kiểm tra kết quả bằng Postman. Tiếp theo chúng ta sẽ kiểm tra kết quả bằng trang web được lưu trữ trên S3. "
},
{
	"uri": "https://tai10012003.github.io/vi/5-apigateway/5.1-createapigateway/",
	"title": "Tạo API Gateway",
	"tags": [],
	"description": "",
	"content": "Tạo API Gateway Trong bước tạo API Gateway này, chúng ta sẽ tạo REST API để hoạt động như một giao diện giữa ứng dụng và Lambda Function. API Gateway sẽ định nghĩa các điểm cuối có cấu trúc (ví dụ: /products, /product) để xử lý các yêu cầu HTTP như GET, POST, PUT và DELETE.\nTìm kiếm API Gateway trong thanh tìm kiếm và nhấp vào API Gateway. Trong Create API, cuộn xuống phần REST API, nhấp vào nút Build. Trong Create REST API, hãy cung cấp các thông tin chi tiết sau: API Name: Nhập tên cho API của bạn (ví dụ: ProductAPI)\nDescription: Thêm mô tả tùy chọn.\nAPI Endpoint Type: Chọn Regional.\nNhấp vào nút Create API để xử lý.\nSau khi tạo REST API, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: Đã tạo REST API thành công.\nTrong phần ProductAPI đã tạo, hãy điều hướng đến phần Resources, nhấp vào nút Create Resource.\nTrong Create resource, thêm các tài nguyên sau: Resource Name: Nhập tên cho tài nguyên: products\nNhấp vào enable CORS (Cross Origin Resource Sharing).\nNhấp vào nút Create resource.\nBạn cần bật CORS để cho phép giao diện lưu trữ trên S3 gửi yêu cầu đến API Gateway, vì giao diện và API Gateway có thể nằm trên các miền hoặc nguồn gốc khác nhau. Nếu CORS không được bật, trình duyệt sẽ chặn các yêu cầu từ giao diện lưu trữ trên S3 đến API Gateway do vi phạm chính sách bảo mật mặc định của trình duyệt, được gọi là Same-Origin Policy.\nSau khi tạo tài nguyên, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: Đã tạo tài nguyên thành công. Tương tự, tạo một tài nguyên khác: product giống như bước 6. Trong Resources, chọn tài nguyên /products và nhấp vào nút Create method: Trong phần Create method, Method details cung cấp các thông tin chi tiết sau: GET:\nMethod Type: chọn GET.\nIntegration Type: chọn Lambda Function.\nNhấp vào bật Lambda proxy integration.\nChọn vùng hiện tại của bạn (ví dụ: us-east-1). Chọn tên Hàm Lambda mà bạn đã tạo trước đó trong phần 4.2. Tạo Hàm Lambda (ví dụ: ProductCRUDFunction)\nCuộn xuống và nhấp vào nút Create method.\nBật Lambda proxy integration: API Gateway chuyển tất cả các yêu cầu HTTP (tiêu đề, truy vấn, nội dung, phương thức) trực tiếp đến Lambda. Lambda xử lý tất cả logic và phản hồi. Nếu không bật Lambda proxy integration: API Gateway chỉ gửi dữ liệu được định cấu hình trước (Mẫu ánh xạ) đến Lambda. Các tham số và phản hồi phải được định cấu hình thủ công trong API Gateway.\nSau khi tạo phương thức, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: phương thức đã được tạo thành công. Tương tự, tạo phương thức POST cho tài nguyên /products. Tương tự, đối với tài nguyên /product, hãy thêm các phương thức sau: GET: Để lấy sản phẩm theo ID.\nPUT: Để cập nhật một sản phẩm.\nDELETE: Để xóa một sản phẩm.\nCấu hình từng method tương tự nhau bằng cách tích hợp nó với Hàm Lambda thích hợp như bước: 9, 10.\nChúng ta đã hoàn tất việc tạo REST API. Tiếp theo chúng ta sẽ Triển khai API. "
},
{
	"uri": "https://tai10012003.github.io/vi/4-lambdafunc/4.1-iamrole/",
	"title": "Tạo IAM Role cho Lambda và DynamoDB",
	"tags": [],
	"description": "",
	"content": "Tạo vai trò IAM cho Lambda và DynamoDB Trong trường hợp này, chúng ta sẽ tạo một vai trò IAM để cho phép Hàm Lambda thực hiện các hoạt động trên DynamoDB. Vai trò IAM này sẽ giúp kết nối Lambda và DynamoDB một cách an toàn mà không cần lưu trữ Access Key trong mã nguồn.\nTìm kiếm IAM trong thanh tìm kiếm và nhấp vào IAM. Trong Bảng điều khiển IAM, hãy chuyển đến phần Roles. Nhấp vào nút Create role. Trong Create role. Cung cấp các thông tin chi tiết sau: Ở bước 1: Select Trusted Entity:\nPhần Trusted entity type: Chọn AWS Service.\nTrong phần Use case: Chọn Lambda làm trường hợp sử dụng.\nNhấp vào nút Next để tiếp tục.\nỞ bước 2: Add permissions:\nTrong phần Permissions policies, hãy sử dụng thanh tìm kiếm để nhập AWSLambda_FullAccess. Khi kết quả xuất hiện, hãy chọn AWSLambda_FullAccess bằng cách đánh dấu tick vào ô bên cạnh. Quyền này cho phép Hàm Lambda có toàn quyền truy cập vào các dịch vụ cần thiết để thực thi mã và quản lý tài nguyên trên AWS.\nTiếp theo, sử dụng thanh tìm kiếm để nhập AmazonDynamoDBFullAccess. Khi kết quả xuất hiện, hãy chọn AmazonDynamoDBFullAccess bằng cách đánh dấu vào ô bên cạnh. Quyền này cho phép Lambda Function thực hiện đầy đủ các thao tác (Tạo, Đọc, Cập nhật, Xóa) trên DynamoDB, đảm bảo tương tác hiệu quả với bảng dữ liệu.\nSau đó, nhấp vào nút Next để tiếp tục.\nỞ bước 3: Name, review and create:\nPhần Role details: Role name: Nhập tên cho vai trò của bạn (ví dụ: role-lambda-dynamo). Description: Thêm mô tả tùy chọn.\nTrong phần Permission policy summary, hãy xem lại các chính sách đính kèm để đảm bảo chúng bao gồm AWSLambda_FullAccess và AmazonDynamoDBFullAccess.\nSau đó, nhấp vào nút Create role để xử lý.\nSau khi tạo vai trò, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: Vai trò đã được tạo thành công. Chúng ta đã hoàn tất việc tạo IAM Role cho Lambda và DynamoDB. Tiếp theo, chúng ta sẽ tạo Hàm Lambda. "
},
{
	"uri": "https://tai10012003.github.io/vi/2-preparation/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Tài khoản AWS Bạn cần có tài khoản AWS để thực hiện bài thí nghiệm này. Nếu bạn không có, vui lòng đăng ký tài khoản AWS.\nĐể tìm hiểu cách tạo tài khoản AWS, bạn có thể tham khảo:\nTạo tài khoản AWS đầu tiên của bạn Các tệp cơ bản Tệp index.html: Giao diện người dùng.\nTệp app.js: Gửi yêu cầu đến API Gateway.\nCác công cụ cần thiết Trình chỉnh sửa mã nguồn:\nVisual Studio Code – Trình chỉnh sửa mã nguồn miễn phí, mạnh mẽ và có thể mở rộng, lý tưởng cho phát triển ứng dụng không có máy chủ. Sử dụng nó để xây dựng giao diện người dùng trong index.html và xử lý các yêu cầu API trong app.js để giao tiếp với API Gateway.\nCài đặt Visual Studio Code từ trang web chính thức của Visual Studio Code.\nCông cụ kiểm tra API:\nPostman – Một công cụ thân thiện với người dùng để kiểm tra API Gateway bằng cách gửi yêu cầu và xác thực phản hồi từ ứng dụng không có máy chủ.\nCài đặt Postman từ trang web chính thức của Postman.\nKích hoạt dịch vụ AWS DynamoDB: Cung cấp cơ sở dữ liệu NoSQL nhanh và có thể mở rộng để quản lý và lưu trữ dữ liệu ứng dụng.\nIAM Role cho Lambda và DynamoDB: IAM Role cho phép Lambda Function thực hiện các hoạt động trên DynamoDB.\nAWS Lambda: Thực thi mã phụ trợ để xử lý logic ứng dụng và tương tác với cơ sở dữ liệu.\nAmazon API Gateway: Quản lý các điểm cuối API RESTful để kết nối giao diện người dùng với các dịch vụ phụ trợ.\nAWS S3: Lưu trữ và cung cấp nội dung tĩnh như HTML, CSS và JavaScript cho giao diện ứng dụng.\n"
},
{
	"uri": "https://tai10012003.github.io/vi/7-testresults/7.2-webs3/",
	"title": "Sử dụng trang web lưu trữ trên S3",
	"tags": [],
	"description": "",
	"content": "Sử dụng trang web lưu trữ trên S3 Trong bước này, chúng ta sẽ kiểm tra trang web lưu trữ trên S3 để đảm bảo trang web hoạt động chính xác và tích hợp liền mạch với API Gateway và Hàm Lambda đã triển khai. Mục tiêu là xác minh rằng giao diện tương tác đúng với giao diện phụ trợ cho tất cả các hoạt động CRUD.\nXác định vị trí bucket nơi lưu trữ các tệp trang web của bạn, chuyển đến tab Properties và tìm phần Static website hosting, sao chép endpoint URL của trang web và mở trong trình duyệt của bạn. Sau khi sao chép endpoint URL của trang web và mở trong trình duyệt của bạn, giao diện sẽ xuất hiện, hiển thị tất cả các tính năng cần thiết để tương tác. Giao diện cung cấp đầy đủ chức năng, giúp bạn dễ dàng kiểm tra và sử dụng ứng dụng. Thêm sản phẩm mới: Sử dụng biểu mẫu trên trang để nhập thông tin chi tiết như ID sản phẩm, tên sản phẩm và giá sản phẩm.\nNhấp vào nút Add Product.\nKết quả: Hiển thị thông báo rằng sản phẩm mới đã được thêm thành công.\nHiển thị danh sách sản phẩm sau khi thêm. Cập nhật thông tin sản phẩm: Cập nhật thông tin chi tiết sản phẩm trong biểu mẫu như ID sản phẩm, tên sản phẩm và giá sản phẩm.\nNhấp vào nút Update Product.\nKết quả: Hiển thị thông báo sản phẩm đã được cập nhật thành công.\nHiển thị danh sách sản phẩm sau khi cập nhật. Xóa thông tin sản phẩm: Nhấp vào nút Delete trong cột Actions.\nXác nhận xóa.\nKết quả: Hiển thị thông báo sản phẩm đã được xóa thành công.\nHiển thị danh sách sản phẩm sau khi xóa. Kiểm tra xem dữ liệu đã được lưu trong DynamoDB chưa. Xin chúc mừng, bạn đã hoàn thành hướng dẫn về thiết lập và thử nghiệm ứng dụng của mình với S3, Lambda, API Gateway và DynamoDB. Hãy đảm bảo dọn sạch mọi tài nguyên chưa sử dụng để tránh các khoản phí không cần thiết.\n"
},
{
	"uri": "https://tai10012003.github.io/vi/4-lambdafunc/4.2-createlambda/",
	"title": "Tạo Hàm Lambda",
	"tags": [],
	"description": "",
	"content": "Tạo Hàm Lambda Trong bước này, chúng ta sẽ tạo một Hàm Lambda xử lý tất cả các hoạt động CRUD (Create, Read, Update, Delete) cho ứng dụng. Hàm Lambda sẽ đóng vai trò là backend, xử lý các yêu cầu nhận được từ API Gateway và tương tác với S3 để quản lý dữ liệu sản phẩm.\nTìm kiếm Lambda trong thanh tìm kiếm và nhấp vào Lambda. Trong bảng điều khiển Lambda của AWS, hãy nhấp vào nút Create a function. Trong Create a function. Cung cấp các thông tin chi tiết sau: Chọn \u0026ldquo;Author from scratch\u0026rdquo;.\nFunction name: Nhập tên cho hàm của bạn (ví dụ: ProductCRUDFunction)\nRuntime: Chọn Python 3.12\nArchitecture: Chọn x86_64.\nPermissions: Trong phần Execution role, chọn Use an existing role, hệ thống sẽ hiển thị phần Existing Role, chọn tên IAM Role mà bạn đã tạo trước đó trong phần 4.1. Tạo IAM Role cho Lambda và DynamoDB\nNhấp vào nút Create function để xử lý.\nSau khi tạo hàm, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: hàm đã được tạo thành công.\nTrong phần ProductCRUDFunction đã tạo, hãy cuộn xuống phần Code source.\nTrong hộp mã nguồn:\nNhấp để chỉnh sửa mã.\nThay thế nội dung lambda_function.py mặc định bằng mã sau:\nimport json import boto3 from decimal import Decimal dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;ProductsTable\u0026#39;) class DecimalEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, Decimal): return float(obj) return super(DecimalEncoder, self).default(obj) def lambda_handler(event, context): path = event.get(\u0026#34;path\u0026#34;) http_method = event.get(\u0026#34;httpMethod\u0026#34;) body = json.loads(event[\u0026#34;body\u0026#34;]) if event.get(\u0026#34;body\u0026#34;) else None query_params = event.get(\u0026#34;queryStringParameters\u0026#34;) if path == \u0026#34;/products\u0026#34; and http_method == \u0026#34;GET\u0026#34;: return get_all_products() elif path == \u0026#34;/products\u0026#34; and http_method == \u0026#34;POST\u0026#34;: return add_product(body) elif path == \u0026#34;/product\u0026#34; and http_method == \u0026#34;GET\u0026#34;: return get_product(query_params.get(\u0026#34;id\u0026#34;) if query_params else None) elif path == \u0026#34;/product\u0026#34; and http_method == \u0026#34;PUT\u0026#34;: return update_product(body) elif path == \u0026#34;/product\u0026#34; and http_method == \u0026#34;DELETE\u0026#34;: return delete_product(query_params.get(\u0026#34;id\u0026#34;) if query_params else None) else: return build_response(404, {\u0026#34;message\u0026#34;: \u0026#34;Endpoint not found\u0026#34;}) def get_all_products(): try: response = table.scan() products = response.get(\u0026#34;Items\u0026#34;, []) for product in products: product[\u0026#34;price\u0026#34;] = float(product[\u0026#34;price\u0026#34;]) return build_response(200, {\u0026#34;products\u0026#34;: products}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def add_product(product): required_fields = {\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;price\u0026#34;} if not product or not required_fields.issubset(product): return build_response(400, {\u0026#34;message\u0026#34;: \u0026#34;Missing required fields\u0026#34;}) try: product[\u0026#34;price\u0026#34;] = Decimal(str(product[\u0026#34;price\u0026#34;])) table.put_item(Item=product) return build_response(201, {\u0026#34;message\u0026#34;: \u0026#34;Product added successfully !\u0026#34;, \u0026#34;product\u0026#34;: product}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def get_product(product_id): if not product_id: return build_response(400, {\u0026#34;message\u0026#34;: \u0026#34;Product ID is required\u0026#34;}) try: response = table.get_item(Key={\u0026#34;id\u0026#34;: product_id}) if \u0026#34;Item\u0026#34; in response: product = response[\u0026#34;Item\u0026#34;] product[\u0026#34;price\u0026#34;] = float(product[\u0026#34;price\u0026#34;]) return build_response(200, {\u0026#34;product\u0026#34;: product}) else: return build_response(404, {\u0026#34;message\u0026#34;: \u0026#34;Product not found\u0026#34;}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def update_product(updated_product): if not updated_product or \u0026#34;id\u0026#34; not in updated_product: return build_response(400, {\u0026#34;message\u0026#34;: \u0026#34;Product ID is required\u0026#34;}) try: table.update_item( Key={\u0026#34;id\u0026#34;: updated_product[\u0026#34;id\u0026#34;]}, UpdateExpression=\u0026#34;SET #n = :name, price = :price\u0026#34;, ExpressionAttributeNames={\u0026#34;#n\u0026#34;: \u0026#34;name\u0026#34;}, ExpressionAttributeValues={ \u0026#34;:name\u0026#34;: updated_product[\u0026#34;name\u0026#34;], \u0026#34;:price\u0026#34;: Decimal(str(updated_product[\u0026#34;price\u0026#34;])), } ) return build_response(200, {\u0026#34;message\u0026#34;: \u0026#34;Product updated successfully !\u0026#34;}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def delete_product(product_id): if not product_id: return build_response(400, {\u0026#34;message\u0026#34;: \u0026#34;Product ID is required\u0026#34;}) try: table.delete_item(Key={\u0026#34;id\u0026#34;: product_id}) return build_response(200, {\u0026#34;message\u0026#34;: \u0026#34;Product deleted successfully !\u0026#34;}) except Exception as e: return build_response(500, {\u0026#34;message\u0026#34;: str(e)}) def build_response(status_code, body): return { \u0026#34;statusCode\u0026#34;: status_code, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET, POST, PUT, DELETE, OPTIONS\u0026#34;, }, \u0026#34;body\u0026#34;: json.dumps(body, cls=DecimalEncoder), } Nhấp vào Deploy (Ctrl+Shift+U) để lưu hàm. Sau khi lưu, hệ thống sẽ hiển thị thông báo: Đã cập nhật thành công hàm ProductCRUDFunction. Chúng ta đã hoàn tất việc tạo Hàm Lambda. "
},
{
	"uri": "https://tai10012003.github.io/vi/6-s3setup/6.2-create-s3/",
	"title": "Tạo S3",
	"tags": [],
	"description": "",
	"content": "Tạo S3 Bucket Trong bước này, chúng ta sẽ tạo S3 bucket để lưu trữ nội dung tĩnh của trang web, chẳng hạn như các tệp HTML, CSS và JavaScript. S3 bucket sẽ được sử dụng để lưu trữ trang web và kích hoạt lưu trữ trang web tĩnh trong các bước tiếp theo. Các tệp tải lên thực tế sẽ được đề cập trong phần 6.3. Tải dữ liệu.\nTìm kiếm S3 trong thanh tìm kiếm và nhấp vào S3. Trong bảng điều khiển S3, nhấp vào nút Create bucket. Trong Create bucket, hãy cung cấp các thông tin chi tiết sau: Trong phần General configuration:\nBucket type: Chọn General purpose.\nBucket Name: Nhập tên cho thùng của bạn, chẳng hạn như my-product-app.\nTrong phần Block Public Access settings for this bucket:\nBỏ chọn Block all public access.\nTurning off block all public access might result in this bucket and the objects within becoming public: Chọn I acknowledge that the current settings might result in this bucket and the objects within becoming public.\nCuộn xuống và Nhấp vào nút Create bucket để xử lý.\nSau khi tạo bucket, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: Đã tạo bucket thành công. Trong phần my-product-app đã tạo, hãy điều hướng đến phần Properties. Cuộn xuống phần Static website hosting, nhấp vào nút Edit. Trong phần Edit static website hosting, cung cấp các thông tin chi tiết sau: Static website hosting: Chọn Enable.\nIndex document: Nhập index.html.\nError documen: Nhập error.html (hoặc để trống) làm tài liệu lỗi.\nCuộn xuống và nhấp vào nút Save changes.\nTrong phần my-product-app, điều hướng đến phần Permissions. Cuộn xuống phần Bucket policy, nhấp vào nút Edit. Trong phần Bucket policy, hãy cung cấp các thông tin chi tiết sau: Trong phần Policy, hãy thêm chính sách sau để cho phép quyền truy cập đọc công khai:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::my-product-app/*\u0026#34; } ] } Thay thế my-product-app bằng tên thùng chính xác của bạn.\nCuộn xuống và nhấp vào nút Save changes. Chúng ta đã hoàn tất việc tạo S3. Tiếp theo chúng ta sẽ tải dữ liệu. "
},
{
	"uri": "https://tai10012003.github.io/vi/5-apigateway/5.2-deployapi/",
	"title": "Triển khai API",
	"tags": [],
	"description": "",
	"content": "Triển khai API Sau khi tạo API RESTful, chúng ta sẽ triển khai API để các điểm cuối có thể truy cập công khai. Điều này liên quan đến việc tạo một new Stage (ví dụ: prod), cho phép API Gateway xử lý các yêu cầu và định tuyến chúng đến Hàm Lambda được kết nối. Bước này đảm bảo API đã sẵn sàng để sử dụng và tích hợp với ứng dụng.\nTrong phần Resources, nhấp vào nút Deploy API. Trong phần Deploy API, Cung cấp các thông tin chi tiết sau: Stage: Chọn New stage.\nStage Name: Nhập tên cho giai đoạn của bạn (ví dụ: prod)\nDescription: Thêm mô tả triển khai (tùy chọn).\nNhấp vào nút Deploy.\nSau khi tạo giai đoạn, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: Đã tạo triển khai thành công cho ProductAPI. Lưu ý Invoke URL cho API đã triển khai (ví dụ: https://{api-id}.execute-api.{region}.amazonaws.com/prod). Chúng ta đã hoàn tất triển khai API. "
},
{
	"uri": "https://tai10012003.github.io/vi/6-s3setup/6.3-load-data/",
	"title": "Tải dữ liệu",
	"tags": [],
	"description": "",
	"content": "Tải dữ liệu Trong bước này, chúng ta sẽ tải các tệp trang web tĩnh (HTML, CSS, JavaScript) vào S3 bucket đã tạo ở bước trước. Thao tác này sẽ cho phép S3 bucket hoạt động như một nền tảng lưu trữ trang web tĩnh cho ứng dụng.\nĐảm bảo bạn đã chuẩn bị các tệp sau: index.html: Tệp chính của trang web của bạn.\napp.js: Chứa mã JavaScript để tương tác với API Gateway.\nTrong phần my-product-app, hãy điều hướng đến phần Objects, sau đó nhấp vào nút Upload. Trong phần Upload: Nhấp vào nút Add files và chọn các tệp tĩnh của bạn (ví dụ: index.html, app.js, v.v.).\nNếu bạn có nhiều tệp được sắp xếp trong các thư mục, hãy nhấp vào nút Add folder.\nChọn tệp index.js và tệp app.js từ máy tính của bạn đã lưu. Cuộn xuống và nhấp vào nút Upload để bắt đầu quy trình. Sau khi tải lên 2 tệp, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: tải lên thành công. Trong phần my-product-app, hãy điều hướng đến phần Properties. Cuộn xuống phần Static website hosting. Lưu ý: URL Bucket website endpoint để sử dụng để kiểm tra kết quả trên trang web (ví dụ: http://my-website-static-bucket.s3-website-us-east-1.amazonaws.com). Chúng ta đã hoàn tất việc tải dữ liệu. "
},
{
	"uri": "https://tai10012003.github.io/vi/3-createdynamodb/",
	"title": "Tạo bảng DynamoDB",
	"tags": [],
	"description": "",
	"content": "Tạo bảng DynamoDB Trong bước này, chúng ta sẽ tạo một bảng DynamoDB để lưu trữ tất cả dữ liệu sản phẩm cho ứng dụng. Bảng sẽ đóng vai trò là cơ sở dữ liệu chính, cho phép các hoạt động CRUD (Tạo, Đọc, Cập nhật, Xóa) thông qua Lambda Function. Mỗi sản phẩm sẽ được lưu trữ dưới dạng một mục trong bảng, với các thuộc tính như ID, name và price. Bảng sẽ được cấu hình để hỗ trợ truy xuất dữ liệu hiệu quả và tương tác thông qua API Gateway và Lambda.\nTừ bảng điều khiển AWS Management, hãy tìm kiếm DynamoDB trong thanh tìm kiếm và nhấp vào DynamoDB. Trong bảng điều khiển AWS DynamoDB, nhấp vào nút Create table. Trong Create table. Cung cấp các thông tin chi tiết sau: Table name: Tên bảng: Nhập tên cho bảng của bạn (ví dụ: ProductsTable)\nPartition Key: Nhập khóa có tên id.\nKey type: Chọn String cho Khóa phân vùng.\nCuộn xuống và nhấp vào nút Create table để xử lý.\nSau khi tạo bảng, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: bảng đã được tạo thành công. Chúng ta đã hoàn tất việc tạo bảng cho DynamoDB. "
},
{
	"uri": "https://tai10012003.github.io/vi/4-lambdafunc/",
	"title": "Hàm Lambda",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ tạo một IAM Role để cấp cho Lambda các quyền cần thiết để tương tác với DynamoDB. Sau đó, chúng ta sẽ thiết lập một Hàm Lambda để xử lý logic cho ứng dụng của mình. Hàm này sẽ hoạt động như một dịch vụ cốt lõi, tích hợp với các thành phần AWS khác.\nNội dung 4.1. Tạo IAM Role cho Lambda và DynamoDB\n4.2. Tạo Lambda Function\n"
},
{
	"uri": "https://tai10012003.github.io/vi/5-apigateway/",
	"title": "API Gateway",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ thiết lập API Gateway để liên kết giao diện người dùng với máy chủ, cho phép tương tác giữa ứng dụng web và Lambda Function. API Gateway sẽ đóng vai trò là trình kết nối, xử lý các yêu cầu HTTP và gửi chúng đến Lambda Function chính xác. Cuối cùng, chúng ta sẽ triển khai API để có thể thử nghiệm và sử dụng.\nNội dung 5.1. Tạo API Gateway\n5.2. Triển khai API\n"
},
{
	"uri": "https://tai10012003.github.io/vi/6-s3setup/",
	"title": "Thiết lập S3",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ tạo một thùng S3 để lưu trữ nội dung tĩnh của trang web, bao gồm các tệp HTML, CSS và JavaScript. Sau đó, chúng ta sẽ tải dữ liệu trang web lên S3 để kích hoạt lưu trữ trang web tĩnh.\nNội dung 6.1. Các tệp dự án cần thiết\n6.2. Tạo S3\n6.3. Tải dữ liệu\n"
},
{
	"uri": "https://tai10012003.github.io/vi/7-testresults/",
	"title": "Kết quả kiểm tra",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ xác minh rằng ứng dụng của chúng ta đang hoạt động chính xác bằng cách kiểm tra API đã triển khai và trang web được lưu trữ trên S3. Các bài kiểm tra này sẽ đảm bảo các điểm cuối API và giao diện người dùng đang hoạt động để thực hiện các hoạt động CRUD.\nNội dung 7.1. Sử dụng Postman\n7.2. Sử dụng trang web được lưu trữ trên S3\n"
},
{
	"uri": "https://tai10012003.github.io/vi/8-cleanup/",
	"title": "Dọn dẹp tài nguyên  ",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ thực hiện các bước sau để xóa các tài nguyên đã tạo trong bài tập này.\nXóa DynamoDB Trong bảng điều khiển AWS DynamoDB, điều hướng đến Tables.\nChọn bảng cần xóa, sau đó nhấp vào nút Delete.\nTrong Delete table, nhập vào ô: confirm và nhấp vào nút Delete.\nSau khi xóa bảng, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: bảng đã được xóa thành công.\nXóa S3 Xóa Object\nTrong bảng điều khiển AWS S3, truy cập phần my-product-app.\nChọn 2 tệp: index.html và app.js, sau đó nhấp vào nút Delete.\nTrong Delete Objects, nhập vào ô: permanently delete và nhấp vào nút Delete objects.\nSau khi xóa đối tượng, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: đối tượng đã được xóa thành công.\nXóa Bucket\nTrong bảng điều khiển AWS S3, chọn mục my-product-app và nhấp vào nút Delete.\nTrong Delete bucket, nhập vào ô tên bucket: my-product-app và nhấp vào nút Delete Bucket.\nSau khi xóa bucket, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: bucket đã được xóa thành công.\nXóa Lambda Trong bảng điều khiển Lambda của AWS, hãy điều hướng đến Functions.\nChọn hàm cần xóa, sau đó nhấp vào nút Actions và nhấp vào nút Delete.\nTrong Delete 1 function, hãy nhập vào ô: delete và nhấp vào nút Delete.\nXóa API Gateway Trong bảng điều khiển API Gateway của AWS, hãy điều hướng đến API.\nChọn API cần xóa, sau đó nhấp vào nút Delete.\nTrong Xóa API, hãy nhập vào ô: confirm và nhấp vào nút Delete.\nSau khi xóa API, một thông báo xác nhận sẽ xuất hiện ở đầu màn hình: API đã được xóa thành công.\n"
},
{
	"uri": "https://tai10012003.github.io/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tai10012003.github.io/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]